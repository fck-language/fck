var searchIndex = JSON.parse('{\
"fck":{"doc":"This is the source code for fck(pure). This is the basis …","t":[0,0,0,0,5,0,5,0,5,0,0,3,3,11,11,11,11,11,11,11,11,12,11,11,12,12,12,11,11,11,11,11,12,11,11,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,11,12,11,11,12,11,11,11,11,11,11,3,3,3,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,11,11,11,11,11,11,11,11,12,11,11,11,11,12,11,11,12,11,11,11,12,12,12,12,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,3,3,11,11,11,11,11,11,11,11,12,11,11,11,11,12,11,11,12,12,11,11,11,5,11,12,11,11,11,11,11,11,11,11,12,11,12,3,3,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,12,12,11,11,11,11,11,11,11,11,11,11,17,17,5,5,5,5,5,5,5,5,5,5,5,3,4,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,5,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,4,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12],"n":["ast","bases","config_file","err_wrn","get_file_name","llvm","main","nodes","run_file","shell","tokens","Lexer","Parser","advance","arith_expr","atom","borrow","borrow","borrow_mut","borrow_mut","call","char_index","comp_expr","conditional_suite_generator","current_char","current_pos","current_tok","expr","factor","finalise","from","from","intermediate","into","into","keyword_code","keywords","make_equals","make_identifier","make_loop_identifier","make_not_equals","make_number","make_set","make_string","make_tokens","nameable_methods","new","new","next","parse","power","previous_end","put_back","safe","single_double_token","skip_comment","skip_newlines","split_text","statement","term","to_process","try_from","try_from","try_into","try_into","type_id","type_id","Context","Position","SymbolTable","Token","advance","advance_ln","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","col","display_name","display_name","fmt","fmt","fmt","fmt","from","from","from","from","full_text","into","into","into","into","ln","matches","matches_list","names_loops","new","new","new","parent","parent","pos_end","pos_start","to_owned","to_owned","to_string","to_string","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_","type_id","type_id","type_id","type_id","ConfigFile","ConfigU8","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","default_lang","fmt","fmt","from","from","history_length","into","into","max_value","min_value","new","new","new_value","read_config_file","set","shell_language_info","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","value","value_type","wrap_length","Error","Warning","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","error_index","fmt","fmt","from","from","into","into","new","pos_end","pos_start","to_owned","to_owned","to_string","to_string","try_from","try_from","try_into","try_into","type_id","type_id","LLVM_FALSE","LLVM_TRUE","build_arith_op","build_ast","build_comp_op","build_if","build_var_assign","get_default_target_triple","init","ir_to_module","llvm_int","object_to_executable","to_object_file","ASTNode","ASTNodeType","ArithOp","As","AsErrorCatch","AtName","Body","Bool","Break","Call","Case","CompOp","Continue","Else","Float","FuncArg","FuncDef","If","Int","Iterate","List","MethodCall","Option","Range","Return","Static","String","Ternary","UnaryMinus","UnaryNot","UnaryPlus","VarAccess","VarAssign","VarGetItem","VarGetRange","VarReassign","VarSubFunc","While","borrow","borrow","borrow_mut","borrow_mut","child_nodes","clone","clone","clone_into","clone_into","eq","fmt","fmt","fmt","from","from","into","into","ne","new","new_v","node_type","pos_end","pos_start","to_owned","to_owned","to_string","try_from","try_from","try_into","try_into","type_id","type_id","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","1","1","2","shell","At","Colon","Comma","Div","Dot","Eq","FDiv","Float","GT","GTE","Identifier","Int","Keyword","LParen","LParenCurly","LParenSquare","LT","LTE","Minus","Mod","Mult","NE","Newline","Not","Plus","Pow","QuestionMark","RParen","RParenCurly","RParenSquare","Set","SetDiv","SetFDiv","SetMinus","SetMod","SetMult","SetPlus","SetPow","String","TokType","borrow","borrow_mut","clone","clone_into","eq","fmt","from","into","ne","to_owned","try_from","try_into","type_id","0","0","0","0","0","0","0","0","0","0","0","0","0","0","1","1"],"q":["fck","","","","","","","","","","","fck::ast","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","fck::bases","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","fck::config_file","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","fck::err_wrn","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","fck::llvm","","","","","","","","","","","","","fck::nodes","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","fck::nodes::ASTNodeType","","","","","","","","","","","","","","","","","","","","","","fck::shell","fck::tokens","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","fck::tokens::TokType","","","","","","","","","","","","","","",""],"d":["Contains the lexer and parser for fck. There are language …","Base file with all the “building blocks” of everything …","Config file handling","","","Everything LLVM related","Reads the local config file and parses arguments …","AST Nodes","","Shell file using JIT compilation","Token enum","Lexer for fck","Parser for fck","Advances the <code>self.current_pos</code> by 1 and updates the …","","","","","","","","The current index of the current character in <code>split_text</code>","","","the current character the pointer is pointing to","Current position of the “pointer”","Current token being processed","","","Called when the <code>self.safe</code> can be changed to <code>false</code>. Clears …","","","An intermediate storage for tokens essentially functioning …","","","The string associated with the current keywords","The current keyword struct words are being checked against","Called by <code>self.make_tokens</code> when a ‘=’ is found. Will …","Called by <code>self.make_tokens</code> when a alphabetic character is …","Called by <code>self.make_tokens</code> when a ‘@’ character is …","Called by <code>self.make_tokens</code> when a ‘!’ is found. Will …","Called by <code>self.make_tokens</code> when a number is found. …","Called by <code>self.make_tokens</code> when a ‘:’ is found. This …","Called by <code>self.make_tokens</code> when an opening string …","Primary function of the lexer. Iterates over the input …","","Returns a new lexer with all fields completed appropriately","Makes a new parser from a <code>Vec&lt;Token&gt;</code>. Reverses the token …","Advances the current token to the next token. Puts the …","Main function. Parses the tokens and returns an …","","Used to store the previous end of the last processed token","Called when the parser needs to back-track. Places the …","Represents if the current token can be discarded after …","General function called by <code>self.make_tokens</code> when we want …","Called by <code>self.make_tokens</code> when a comment is found. This …","Skips new lines. Don’t care about them","Input text split into a vector of characters","First grammar rule","","Vector of tokens current un-processed","","","","","","","","Position container. Is the basis for positions of tokens …","","Token struct. Used by the lexer and parser","Advances and returns the position by adding one to <code>self.col</code>","Adds one to <code>self.ln</code> and sets <code>self.col</code> to 0","","","","","","","","","","","","","Column number","","","","","","","","","","","","","","","","Line number","Checks is a token matches a specific type and value","Checks if a token is a keyword in a specific keyword list","","","Creates a new position at (0,0)","Generates a new token from a given token type, value, and …","","","Ending position. This is really one after the ending …","Starting position","","","","","","","","","","","","","The token type from <code>tokens.rs</code>","","","","","Config file struct that holds all the configurable options","Special type of u8 with a minimum and maximum value. Used …","","","","","","","","","The language to use if no language is specified. Also …","","","","","Number of previous lines to save when using the shell","","","","","Creates a new ConfigFile strict from a given initial …","Creates a new ConfigU8 from a current, min, and max value","Set a certain config option, indexed by value: 0. wrap …","Parses the config file and returns a <code>ConfigFile</code> struct","Sets a new value. If this new value is outside of the …","","","","","","","","","","","Function to determine what type of value each configurable …","Wrap length of errors and warnings","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","False constant of type <code>LLVMBool</code>","True constant of type <code>LLVMBool</code>","Builds a <code>ASTNodeType::ArithOp</code> AST node to the module","Builds the ASTs to the module","","","Builds a <code>ASTNodeType::VarAssign</code> AST node to the module","Gets the default target string","Initialise LLVM","Main function of the file. Turns the asts into an LLVM …","Useful function to make an integer","convert the object file into an executable using clang","Builds a module to an object file","AST node","AST node types","","","","","Node to contain the body of a conditional or function","Boolean type","","","","","","","Float type","","","","Integer type","","List type","","","","","","String type","","","","","Variable access. Holds the variable name(language …","Variable assignment. Holds if the variable should be …","","","","","","","","","","Child nodes","","","","","","","","","","","","","","Create a new AST node","Create a new AST node with no children. Quality of life …","AST node type","Ending position of the AST","Starting position of the AST","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","JIT shell","At identifier","Colon","Comma","Divide operator","Dot","Equals operator","Floor divide operator","Float literal","Greater than operator","Greater than or equals operator","Identifier. Holds identifier string and language key","Integer literal","Keyword","Left parentheses (","Left curly parentheses {","Left square parentheses [","Less than operator","Less than or equals operator","Minus operator","Modulus operator","Multiply operator","Not equals operator","New line","Boolean negation","Plus operator","Power operator","Question mark","Right parentheses )","Right curly parentheses }","Right square parentheses ]","Variable assignment","Divide variable","Floor divide variable","Subtract value from current variable","Modulus current variable","Multiply variable","Add value to current variable","Power current variable","String literal","Token type enum","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,2,1,2,2,1,2,2,1,1,2,2,2,2,1,2,2,1,2,1,1,1,1,1,1,1,1,1,1,2,1,2,2,2,2,2,2,2,1,1,2,1,2,2,2,1,2,1,2,1,2,0,0,0,0,3,3,4,5,3,6,4,5,3,6,3,6,3,6,3,4,5,3,3,6,6,4,5,3,6,4,4,5,3,6,3,6,6,5,4,3,6,4,5,6,6,3,6,3,6,4,5,3,6,4,5,3,6,6,4,5,3,6,0,0,7,8,7,8,7,8,7,8,7,7,8,7,8,7,7,8,8,8,7,8,7,0,8,7,7,8,7,8,7,8,7,8,8,7,7,0,0,9,10,9,10,9,10,9,10,9,9,10,9,10,9,10,9,9,9,9,10,9,10,9,10,9,10,9,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,12,12,11,12,11,12,11,11,12,12,11,12,11,12,11,12,12,12,12,12,11,12,12,11,12,11,12,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,18,19,18,0,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,0,32,32,32,32,32,32,32,32,32,32,32,32,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,37,38],"f":[null,null,null,null,[[["str",15]],["string",3]],null,[[]],null,[[["str",15],["configfile",3],["bool",15],["bool",15],["bool",15]]],null,null,null,null,[[]],[[],["result",4,[["astnode",3],["error",3]]]],[[],["result",4,[["astnode",3],["error",3]]]],[[]],[[]],[[]],[[]],[[],["result",4,[["astnode",3],["error",3]]]],null,[[],["result",4,[["astnode",3],["error",3]]]],[[],["result",4,[["astnode",3],["error",3]]]],null,null,null,[[],["result",4,[["astnode",3],["error",3]]]],[[],["result",4,[["astnode",3],["error",3]]]],[[]],[[]],[[]],null,[[]],[[]],null,null,[[],["result",4,[["token",3],["error",3]]]],[[],["token",3]],[[],["result",4,[["token",3],["error",3]]]],[[],["result",4,[["token",3],["error",3]]]],[[],["token",3]],[[],["result",4,[["token",3],["error",3]]]],[[["char",15]],["result",4,[["token",3],["error",3]]]],[[],["result",4,[["vec",3,[["token",3]]],["error",3]]]],[[["option",4,[["string",3]]]],["result",4,[["astnode",3],["error",3]]]],[[["string",3],["keywords",3],["string",3]],["lexer",3]],[[["vec",3,[["token",3]]]],["parser",3]],[[]],[[],["result",4,[["vec",3,[["astnode",3]]],["error",3]]]],[[],["result",4,[["astnode",3],["error",3]]]],null,[[]],null,[[["char",15],["toktype",4],["toktype",4]],["result",4,[["token",3],["error",3]]]],[[]],[[]],null,[[],["result",4,[["astnode",3],["error",3]]]],[[],["result",4,[["astnode",3],["error",3]]]],null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["position",3]],[[],["token",3]],[[]],[[]],null,null,null,[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],null,[[]],[[]],[[]],[[]],null,[[["toktype",4]],["bool",15]],[[["u8",15]],["bool",15]],null,[[["string",3],["string",3],["option",4,[["context",3]]]],["context",3]],[[],["position",3]],[[["toktype",4],["position",3],["position",3]],["token",3]],null,null,null,null,[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],null,[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,[[]],[[]],[[]],[[]],[[],["configfile",3]],[[],["configu8",3]],[[]],[[]],null,[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],null,[[]],[[]],null,null,[[["string",3]],["configfile",3]],[[["u8",15],["u8",15],["u8",15]],["configu8",3]],[[["usize",15],["option",4,[["u8",15]]],["option",4,[["string",3]]]]],[[],["configfile",3]],[[["u8",15]]],null,[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],null,[[["usize",15]],["u8",15]],null,null,null,[[]],[[]],[[]],[[]],[[],["error",3]],[[],["warning",3]],[[]],[[]],null,[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[["position",3],["position",3],["u16",15]],["error",3]],null,null,[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],null,null,[[["module",3],["llvmbasicblockref",6],["llvmvalueref",6],["vec",3,[["char",15]]],["vec",3,[["astnode",3]]]]],[[["module",3],["llvmbasicblockref",6],["llvmvalueref",6],["astnode",3]]],[[["module",3],["llvmbasicblockref",6],["llvmvalueref",6],["vec",3,[["char",15]]],["vec",3,[["astnode",3]]]]],[[["module",3],["llvmbasicblockref",6],["llvmvalueref",6],["vec",3,[["astnode",3]]]]],[[["module",3],["llvmbasicblockref",6],["llvmvalueref",6],["bool",15],["u8",15],["string",3],["astnode",3]]],[[],["cstring",3]],[[]],[[["str",15],["vec",3,[["astnode",3]]]],["module",3]],[[["c_ulonglong",6],["llvmtyperef",6]],["llvmvalueref",6]],[[["string",3]]],[[["string",3]]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],null,[[],["astnodetype",4]],[[],["astnode",3]],[[]],[[]],[[["astnodetype",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[["astnodetype",4]],["bool",15]],[[["astnodetype",4],["vec",3,[["astnode",3]]],["position",3],["position",3]],["astnode",3]],[[["astnodetype",4],["position",3],["position",3]],["astnode",3]],null,null,null,[[]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["configfile",3],["bool",15],["bool",15]]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["toktype",4]],[[]],[[["toktype",4]],["bool",15]],[[["formatter",3]],["result",6]],[[]],[[]],[[["toktype",4]],["bool",15]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"p":[[3,"Lexer"],[3,"Parser"],[3,"Position"],[3,"Context"],[3,"SymbolTable"],[3,"Token"],[3,"ConfigFile"],[3,"ConfigU8"],[3,"Error"],[3,"Warning"],[4,"ASTNodeType"],[3,"ASTNode"],[13,"Int"],[13,"Float"],[13,"Bool"],[13,"String"],[13,"VarAccess"],[13,"VarAssign"],[13,"Ternary"],[13,"ArithOp"],[13,"CompOp"],[13,"As"],[13,"If"],[13,"Case"],[13,"Iterate"],[13,"While"],[13,"FuncDef"],[13,"FuncArg"],[13,"Return"],[13,"Continue"],[13,"Break"],[4,"TokType"],[13,"Int"],[13,"Float"],[13,"String"],[13,"At"],[13,"Identifier"],[13,"Keyword"],[13,"Set"],[13,"SetPlus"],[13,"SetMinus"],[13,"SetMod"],[13,"SetMult"],[13,"SetDiv"],[13,"SetFDiv"],[13,"SetPow"]]},\
"lang":{"doc":"Language handling","t":[0,0,0,5,5,0,0,17,17,17,17,17,17,3,3,3,3,11,11,11,11,11,11,11,11,11,11,12,11,12,12,12,12,11,11,11,11,12,11,11,11,11,12,12,12,12,12,11,11,11,11,11,11,11,11,11,12,11,11,11,11,12,12,17,17],"n":["de","en","fr","get_associated_keywords","get_associated_messages","keywords","ko","KEYWORDS","MESSAGES","KEYWORDS","MESSAGES","KEYWORDS","MESSAGES","ErrorHolder","ErrorMessages","Keywords","Messages","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","config_keys","contains","desc","errors","expected_errors","flavours","from","from","from","from","generic","into","into","into","into","keywords","language_errors","manifest_keys","name","not_here_errors","to_owned","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_errors","type_id","type_id","type_id","type_id","unknown_errors","var_keywords","KEYWORDS","MESSAGES"],"q":["lang","","","","","","","lang::de","","lang::en","","lang::fr","","lang::keywords","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","lang::ko",""],"d":["Language file for German","Language file for English","Language file for French","Returns (assuming the language code is valid) the keywords …","Returns (assuming the language code is valid) the messages …","Structs for the languages","Language file for Korean","","","","","","","Error and warning related messages","Error message struct","Keyword struct","Messages for different events","","","","","","","","","","","Config file keys","Checks is an identifier is either a keyword or variable …","Error description","Error and warning related messages","Expectation errors relating to the parser expecting …","Flavour names. This will robably be changed later","","","","","Generic messages. Currently only holding a message about …","","","","","General keywords","Errors related to the language part of fck Code 00**","Manifest file keys","Error name","Errors relating to the use of something where it can’t be","","","","","","","","","","Type related errors, such as returning the wrong type Code …","","","","","Unknown item errors Code 01**","Variable keywords","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,1,2,3,4,4,4,4,4,3,1,2,4,1,2,3,4,1,1,2,3,4,4,2,4,3,2,4,1,2,3,4,1,2,3,4,2,1,2,3,4,2,4,0,0],"f":[null,null,null,[[["str",15]],["option",4,[["keywords",3]]]],[[["str",15]],["option",4,[["messages",3]]]],null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["keywords",3]],[[]],null,[[["str",15]],["option",4]],null,null,null,null,[[]],[[]],[[]],[[]],null,[[]],[[]],[[]],[[]],null,null,null,null,null,[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],null,[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null],"p":[[3,"Messages"],[3,"ErrorHolder"],[3,"ErrorMessages"],[3,"Keywords"]]},\
"type_things":{"doc":"fck type handling system","t":[0,0,0,3,3,3,12,11,11,11,11,11,11,11,11,12,3,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["checker","prelude","primitives","FuncArg","FuncCallSig","Module","blank","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","current_fn","fckType","fmt","fmt","from","from","from","from","hash","hash","into","into","into","into","module","new","new_ptr_i8","to_string","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id"],"q":["type_things","","","type_things::prelude","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["","Main structs required by most otherthings","","Function argument","Function holder for the type struct","Holder for LLVMModule","Blank CString used as the default block name","","","","","","","","","Current function to make sure that any new blocks are …","Generic type struct","Returns the LLVM IR code","","","","","","","","","","","","LLVMModule that things get build to","Initialise a new Module","Make a new CString and return it as a <code>*const i8</code>","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,1,2,3,4,1,2,3,4,1,1,0,1,1,2,3,4,1,3,4,2,3,4,1,1,1,1,1,2,3,4,1,2,3,4,1,2,3,4,1],"f":[null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],null,null,[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],null,[[]],[[["str",15]]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]]],"p":[[3,"Module"],[3,"fckType"],[3,"FuncCallSig"],[3,"FuncArg"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};