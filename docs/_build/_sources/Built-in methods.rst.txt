.. role:: warning

Built-in methods
================

While loop
----------
::

    while <condition> {
        <suite>
    }

The ``while`` loop executes a given suite while the given condition is true. ``while`` loops can be named. See the naming methods section for how to name methods.

Iterate loop
------------
::

    iterate <range> {
        <suite>
    }

The ``iterate`` loop executes a given suite a given number of times. As with ``while`` loops, ``iterate`` loops can be named. See the naming methods section for how to name methods.

Range based iteration
^^^^^^^^^^^^^^^^^^^^^
::

    (<first value> to)? <second value> (step <step value>)?  (:: <iterable variable>)?

The ``range`` of an iterate loop is very flexible and has several optional parts for range based iteration.

If a first value is not given, this is assumed to be 0. The first value is the starting value, and the iteration ends when the current value is larger than or equal to the second value if the step value is positive, and less than or equal to the second value if the step value is negative. The step value can be any finite value, positive or negative. If the step value is given as 0, a warning is raised and the step value defaults back to Â±1 depending on the value of the second value in relation to the first value.

The iterable variable is a temporary variable assigned to the current value being iterated over at the start of each iteration. This value **can** be overwritten during the iteration and is not rewritten by the iterate loop. Once the iterate loop has finished this variable is removed from the global scope.

Due to the flexibility and design principles of fck, there are several cases in which warnings can be raised. These are given below:

+------------------------------------+-----------------------------------------------------------------+
|Case                                |What fck does to fix this                                        |
+------------------------------------+-----------------------------------------------------------------+
|First value is lower than the       |The step value is made positive                                  |
|second value and the step value is  |                                                                 |
|negative                            |                                                                 |
+------------------------------------+-----------------------------------------------------------------+
|Second value is lower than the      |The step value is made negative                                  |
|first value and the step value is   |                                                                 |
|positive                            |                                                                 |
+------------------------------------+-----------------------------------------------------------------+
|Step value is 0                     |The step value is set to 1 if the second value is larger than    |
|                                    |the first value, else -1                                         |
+------------------------------------+-----------------------------------------------------------------+

Method naming
-------------

In fck, methods can be named for use in conjunction with the ``break`` and ``continue`` keywords. To name a method, the ``@`` character is used followed by the name, and then the method. For example: ::

    @loop while <condition> {
        <suite>
    }

If multiple methods are given the same name, these names will be altered with the suffix of 1, 2, 3 etc. assuming that these names do not exist either, with the exception of the first name, which will be left unaltered. :warning:`This will raise a warning.`

Condition evaluation
--------------------

Conditions are evaluated differently in fck when compared to many coding languages. The table below details how different types of conditions are evaluated:

============== ================================
Condition type How is it evaluated to a boolean
============== ================================
Numerical      If the value is above 0, the
               condition evaluates to ``true``
``string``     If the length of the string is
               0 it evaluates to ``false``
``list``       If the length contains no values
               (or recursively contains a list with no items in)
               it evaluates to ``false``
============== ================================

The ``list`` is a slightly confusing entry since it's a fairly complex evaluation. When a list is evaluated as a condition, if the list has nothing in, it returns ``false``. If the list **only** has  a list inside it, ths list is evaluated instead. If neither of these are true then the list is evaluated as ``true``. See below for some examples:


=================== ==========
List                Evaluation
=================== ==========
``[]``              ``false``
``[[]]``            ``false``
``[[], 1]``         ``true``
``[5]``             ``true``
``["hello world"]`` ``true``
=================== ==========
